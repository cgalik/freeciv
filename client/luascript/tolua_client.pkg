/*****************************************************************************
 Freeciv - Copyright (C) 2005 - The Freeciv Project
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
*****************************************************************************/

/*****************************************************************************
  ADVERTISEMENT: do not attempt to change the name of the API functions.
  They *must* be compatible between the minor Freeciv versions within the
  same major version. If you really like to change a function name, be sure
  to keep also the old one running.
*****************************************************************************/

$#ifdef HAVE_CONFIG_H
$#include <fc_config.h>
$#endif

/* common/scriptcore */
$#include "luascript_types.h"

/* client/luascript */
$#include "api_client_base.h"
$#include "script_client.h"

/* Chat module. */

module chat {
  void api_client_chat_base
    @ base (lua_State *L, const char *message);
}

$[

-- Chat module implementation.

function chat.msg(fmt, ...)
  chat.base(string.format(fmt, ...))
end

$]

/* client module */
module client {
  Player *api_client_player @ player(lua_State *L);
  void api_client_center @ center(lua_State *L, Tile* tile);
  void api_client_center_coords
    @ center(lua_State *L, int x, int y);
  const char *api_client_state @ state(lua_State *L);
  const char *api_client_tileset_name @ tileset_name(lua_State *L);
  lua_Object api_client_option_get
    @ option (lua_State *L, const char *name, bool is_server_opt);
  const char* api_client_option_next
    @ option_next (lua_State *L, const char *name, bool is_server_opt);
}

/* focus module */
module focus {
  void api_client_unit_focus_add @ add(lua_State *L, Unit *punit);
  void api_client_unit_focus_remove @ remove (lua_State *L, Unit *punit);
  bool api_client_unit_is_in_focus @ contains (lua_State *L, Unit *punit);
  int api_client_num_units_in_focus @ number(lua_State *L);
}

module methods_private {
  module focus {
    Unit_List_Link *api_client_private_focus_head @ head(lua_State *L);
  }
}

$[
--no () for client.player etc., pseudo-tables for options
--Currently, client has no metatable, but ever may get, thus so polymorphic
do
  local cli_mt = getmetatable(client)
  local clindex
  local oo = {state = client.state,
    tileset_name = client.tileset_name,
    player = client.player}
  local opt, sopt, cliopt, clinext
    = {}, {}, client.option, client.option_next
  if cli_mt then
    clindex = cli_mt.__index
  else
    cli_mt = {}
    setmetatable(client, cli_mt)
  end
  for k, _ in pairs(oo) do client[k] = nil end --access via __index
  if not clindex then
    clindex = function(t, k) return rawget(t, k) end
  end
  local function smtos(o, is_srv)
    setmetatable(o, {
      __index = function(t, n)
        return cliopt(n, is_srv)
      end,
      __pairs = function(t)
        return function(t1, i)
            local n = clinext(i, is_srv)
            return n, t1[n]
          end, t, nil
      end
    })
  end
  smtos(opt, false)
  smtos(sopt, true)
  cli_mt.__index = function(c, n)
    if oo[n] then
      return oo[n]()
    elseif n == "option" then
      return opt
    else
      return clindex(c, n)
    end
  end
  game.server_option = sopt
  
  -- focus iteration
  local focus_head = methods_private.focus.head
  function focus.list() -- Note: units can be destroyed afterwards
    local list, link = {}, focus_head()
    while link do
      table.insert(list, link:data())
      link = link:next()
    end
    return list
  end
  -- The iterator can be called between pakets processings that will
  -- remove the units, so make it safe. TODO: client remove units correctly
  function focus.iterate() 
    local idlist, i, n, link = {}, 1, focus.number(), focus_head();
    for j = 1, n do
      idlist[j] = link:data().id
      link = link:next()
    end
    return function()
      local u
      while i <= n do
        u = find.unit(nil, idlist[i])
        i = i + 1
        if u then break end
      end
      return u
    end
  end
end

Tile.center = client.center
$]

module Unit {
  module properties{
    bool api_client_unit_occupied
      @ occupied (lua_State *L, Unit *punit);
    bool api_client_unit_is_in_focus @ selected (lua_State *L, Unit *punit);
  }
  void api_client_unit_focus_add
    @ select (lua_State *L, Unit *punit);
  void api_client_unit_focus_remove
    @ unselect (lua_State *L, Unit *punit);

  /* control methods */
  void api_client_unit_airlift
    @ airlift (lua_State *L, Unit *punit, City *pcity);
  void api_client_unit_load
    @ load (lua_State *L, Unit *pcargo, Unit *ptransport);
  void api_client_unit_unload
    @ unload_from (lua_State *L, Unit *pcargo, Unit *ptransport=NULL);
  bool api_client_unit_move
    @ goto (lua_State *L, Unit *punit, Tile *ptile);
  void api_client_unit_upgrade
    @ upgrade (lua_State *L, Unit *punit);
  void api_client_unit_build_city
    @ build_city (lua_State *L, Unit *punit, const char *name=NULL);
  void api_client_unit_give_orders
    @ give_orders (lua_State *L, Unit *punit, lua_Object seq,
                   bool vigilant = FALSE, bool rep = FALSE);
  void api_client_unit_request_activity_targeted
    @ request_activity (lua_State *L, Unit *punit, const char *activity_name,
                        const char *target = NULL);
  /* keep string form first */
  void api_client_unit_do_action_name
    @ do_action (lua_State *L, Unit *punit, const char *name,
                 lua_Object target = 0, lua_Object value = 0);
  void api_client_unit_do_action
    @ do_action (lua_State *L, Unit *punit, const Action *paction,
                 lua_Object target = 0, lua_Object value = 0);
  void api_client_unit_do_action_id
    @ do_action (lua_State *L, Unit *punit, int act, lua_Object target = 0,
                 lua_Object value = 0);
}

$[
  -- Unloads something from something appropriate
  function Unit:unload(uother)
    if uother:transporter() == self then
      uother:unload_from(self)
    else
      self:unload_from(uother)
    end
  end
$]

module City {
  module properties{
    bool api_client_city_occupied
      @ occupied (lua_State *L, City *pcity);
    const char *api_client_city_cma_name
      @ cma_name (lua_State *L, City *pcity);
  }
  void api_client_city_change_production
    @ change_production (lua_State *L, City *pcity, lua_Object prod);
  void api_client_city_change_specialist
    @ change_specialist(lua_State *L, City *pcity,
                        const char *s_from, const char *s_to);
  bool api_client_city_make_worker
    @ work (lua_State *L, City *pcity, Tile *ptile);
  bool api_client_city_make_specialist
    @ release (lua_State *L, City *pcity, Tile *ptile);
  /* Overwriting common values (TODO: move them to tolua_server.pkg) */
  bool api_client_is_city_happy
    @ is_happy (lua_State *L, City *pcity);
  bool api_client_is_city_unhappy
    @ is_unhappy (lua_State *L, City *pcity);
}

$[
-- Toggles a worker on a tile, does nothing to city center unless asked
function City:toggle(t, aaw)
  if not aaw then
    if not t or self.tile == t then
      return false
    end
  end
  if t.worked == self then
    return self:release(t)
  else
    return self:work(t)
  end
end
-- Auto-arrange workers
function City:auto_arrange()
  self:work()
end
$]
